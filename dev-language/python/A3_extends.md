# 继承

## 目标
单继承
多继承

## 面向对象三大特性
1. 封装 根据 职责 将 属性 和 方法 封装 到一个抽象的 类 中
2. 继承 实现代码的重用，相同的代码不需要重复的编写
3. 多态 不同的对象调用相同的方法，产生不同的执行结果，增加代码的灵活度

### 01. 单继承
#### 1.1 继承的概念、语法和特点
继承的概念：子类 拥有 父类 的所有 方法 和 属性  

![img](./images/py_a3_1.png)

##### 1) 继承的语法  
```
class 类名(父类名):

    pass

```
1. 子类 继承自 父类，可以直接 享受 父类中已经封装好的方法，不需要再次开发
2. 子类 中应该根据 职责，封装 子类特有的 属性和方法


##### 2) 专业术语
1. Dog 类是 Animal 类的子类，Animal 类是 Dog 类的父类，Dog 类从 Animal 类继承
2. Dog 类是 Animal 类的派生类，Animal 类是 Dog 类的基类，Dog 类从 Animal 类派生


##### 3) 继承的传递性
1. C 类从 B 类继承，B 类又从 A 类继承
2. 那么 C 类就具有 B 类和 A 类的所有属性和方法
__子类__ 拥有 __父类__ 以及 __父类的父类__ 中封装的所有 __属性__ 和 __方法__

提问:  
哮天犬 能够调用 Cat 类中定义的 catch 方法吗？

答案:  
不能，因为 哮天犬 和 Cat 之间没有 继承 关系


#### 1.2 方法的重写
1. 子类 拥有 父类 的所有 方法 和 属性
2. 子类 继承自 父类，可以直接 享受 父类中已经封装好的方法，不需要再次开发

应用场景:  
当 __父类__ 的方法实现不能满足子类需求时，可以对方法进行 __重写(override)__

![img](./images/py_a3_2.png)

__重写__ 父类方法有两种情况：
    __覆盖__ 父类的方法
    对父类方法进行 __扩展__
    
##### 1) 覆盖父类的方法
1. 如果在开发中， __父类的方法实现__ 和 __子类的方法实现，完全不同__
2. 就可以使用 __覆盖__ 的方式，在子类中 __重新编写__ 父类的方法实现
3. 具体的实现方式，就相当于在 __子类中__ 定义了一个 __和父类同名的方法并且实现__

重写之后，在运行时，只会调用 __子类中重写的方法，而不再会调用 父类封装的方法__

##### 2) 对父类方法进行 扩展

1. 如果在开发中，子类的方法实现 中 __包含__ 父类的方法实现
2. 父类原本封装的方法实现 是 __子类方法的一部分__
3. 就可以使用 __扩展__ 的方式
4. 在子类中 __重写__ 父类的方法:  
    在需要的位置使用 __super().父类方法__ 来调用父类方法的执行  
    代码其他的位置针对子类的需求，编写 子类特有的代码实现  

__关于 super__  
在 __Python__ 中 __super__ 是一个 __特殊的类__  
__super()__ 就是使用 __super__ 类创建出来的对象  
最常 __使用的场景就是在__ 重写父类方法时，调用 __在父类中封装的方法实现__    

5. 调用父类方法的另外一种方式（知道）   
在 Python 2.x 时，如果需要调用父类的方法，还可以使用以下方式：  
```
父类名.方法(self)
```
这种方式，目前在 __Python 3.x__ 还支持这种方式  
这种方法 __不推荐使用__ ，因为一旦 __父类发生变化__ ，方法调用位置的 __类名__ 同样需要修改  

    提示:  
    在开发时，父类名 和 super() 两种方式不要混用
    如果使用 当前子类名 调用方法，会形成递归调用，出现死循环



### 1.3 父类的 私有属性 和 私有方法
__子类对象 不能__ 在自己的方法内部，直接 __访问 父类的 私有属性 或 私有方法__  
__子类对象__ 可以通过 __父类__ 的 __公有方法__ 间接 __访问到__ __私有属性 或 私有方法__  
__私有属性、方法__ 是对象的隐私，不对外公开， __外界__ 以及 __子类__ 都不能直接访问  
__私有属性、方法__ 通常用于做一些内部的事情  

![img](./images/py_a3_3.png)

1. B 的对象不能直接访问 \_\_num2 属性  
2. B 的对象不能在 demo 方法内访问 \_\_num2 属性  
3. B 的对象可以在 demo 方法内，调用父类的 test 方法  
4. 父类的 test 方法内部，能够访问 \_\_num2 属性和 \_\_test 方法  


## 02. 多继承

概念:  
子类 可以拥有 多个父类，并且具有 所有父类 的 __属性 和 方法__   
例如： __孩子__ 会继承自己 __父亲 和 母亲__ 的 特性  

![img](./images/py_a3_4.png)

```
class 子类名(父类名1, 父类名2...)
    pass
```

### 2.1 多继承的使用注意事项
问题的提出:  
如果 不同的父类 中存在 同名的方法，子类对象 在调用方法时，会调用 哪一个父类中的方法呢？  
提示：开发时，应该尽量避免这种容易产生混淆的情况！ —— 如果 __父类之间__ 存在 __同名的属性或者方法__，应该 __尽量避免__ 使用多继承  

![img](./images/py_a3_5.png)


__Python 中的 MRO —— 方法搜索顺序（知道）__ :   
1. Python 中针对 类 提供了一个 内置属性 \_\_mro\_\_ 可以查看 方法 搜索顺序  
2. MRO 是 __method resolution order__ ，主要用于 在多继承时判断 __方法、属性 的调用 路径__   

```
print(C.__mro__)
# 输出结果
# (<class '__main__.C'>, <class '__main__.A'>, <class '__main__.B'>, <class 'object'>)
```

1. 在搜索方法时，是按照 \_\_mro\_\_ 的输出结果 从左至右 的顺序查找的
2. 如果在当前类中 找到方法，就直接执行，不再搜索
3. 如果 没有找到，就查找下一个类 中是否有对应的方法，如果找到，就直接执行，不再搜索
4. 如果找到最后一个类，还没有找到方法，程序报错   



### 2.2 新式类与旧式（经典）类
object 是 Python 为所有对象提供的 基类，提供有一些内置的属性和方法，可以使用 dir 函数查看

1. 新式类：以 __object__ 为基类的类，推荐使用  
2. 经典类：不以 __object__ 为基类的类，不推荐使用  
3. 在 Python 3.x 中定义类时，如果没有指定父类，会 __默认使用 object__ 作为该类的 __基类__ —— Python 3.x 中定义的类都是 __新式类__  
4. 在 Python 2.x 中定义类时，如果没有指定父类，则不会以 __object__ 作为 __基类__   


__新式类 和 经典类 在多继承时 —— 会影响到方法的搜索顺序__ :  

1. 为了保证编写的代码能够同时在 Python 2.x 和 Python 3.x 运行！  
2. 今后在定义类时，如果没有父类，建议统一继承自 object  

```
class 类名(object):
    pass
```


